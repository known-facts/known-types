require 'json'
require 'pathname'
require 'yaml'
require './rust.rb'

HEADER = "This is free and unencumbered software released into the public domain."
BASE_URL = 'https://platform.openai.com'
OneOf = Rust::Types::Unit.new(:OneOf)
AnyOf = Rust::Types::Unit.new(:AnyOf)
AllOf = Rust::Types::Unit.new(:AllOf)

namespace :codegen do
  task components: %w(openapi.yaml) do |t|
    spec = OpenAI::Spec.parse(t.prerequisites.first)

    File.open('src/components.rs', 'w') do |out|
      out.puts "// #{HEADER}"
      out.puts
      out.puts "//! OpenAI API components"
      out.puts
      out.puts "#![allow(non_camel_case_types)]"
      out.puts
      out.puts "use crate::prelude::{String, Vec};"

      spec.schemas.each do |schema|
        out.puts

        module_name = camel_to_snake(schema.id.to_s)
        module_path = Pathname("components/#{module_name}.rs")

        if (Pathname('src') / module_path).exist?
          out.puts "include!(\"#{module_path}\");"
          next
        end

        definitions = case
          when schema.one_of?
            # Some 23 schemas are `oneOf`.
            #puts JSON.pretty_generate(schema.to_h)
            [Rust::Enum.new(schema.id, derives: %i(Clone Debug)) do |definition|
              definition.comment = schema.summary
              # out.puts "#[default]" if schema.nullable? # TODO: && schema.default == 'null'
              definition.variants << Rust::Variant.new(:Null) if schema.nullable?
              schema.one_of.each do |t|
                #p [:ONE_OF, schema.id]
                variant = Rust::Variant.new(t.to_rust_variant, t.to_rust)
                variant.comment = t.summary
                definition.variants << variant
              end
            end]
          when schema.any_of?
            # Only 10 schemas are `anyOf`.
            [Rust::Newtype.new(schema.id, AnyOf, derives: %i(Clone Debug)) do |definition|
              definition.comment = schema.summary
            end] # TODO
          when schema.all_of?
            # Only 9 schemas are `allOf`.
            [Rust::Newtype.new(schema.id, AllOf, derives: %i(Clone Debug)) do |definition|
              definition.comment = schema.summary
            end] # TODO
          when schema.items? || schema.type == :array
            # Only 4 schemas are `type: "array"`.
              [Rust::Newtype.new(schema.id, Rust::Types::Vec.new(schema.items.to_rust)) do |definition|
              definition.comment = schema.summary
            end]
          when schema.properties? || schema.type == :object
            # Some 414 schemas are `type: "object"`.
            related_definitions = []
            definition = Rust::Struct.new(schema.id, derives: %i(Clone Debug)) do |definition|
              definition.comment = schema.summary
              schema.properties.each do |(property_id, property_type)|
                field_type = property_type.to_rust
                field = Rust::Field.new(property_id, field_type)
                field.comment = property_type.summary
                field.rename = property_id.id if property_id.needs_rename?
                definition.fields << field
                related_definitions += property_type.related_types
              end
            end
            [definition] + related_definitions
          else case schema.type
            # Only `ParallelToolCalls` has `type: "boolean"`.
            # TODO: schema['default'] if schema.type == :boolean
            when :boolean then [Rust::Newtype.new(schema.id, Rust::Types::Bool) do |definition|
              definition.comment = schema.summary
            end]
            # Some 12 schemas are `type: "string"`.
            when :string then [Rust::Newtype.new(schema.id, Rust::Types::String) do |definition|
              definition.comment = schema.summary
            end]
            else raise NotImplementedError # unreachable
          end
        end

        definitions.each_with_index do |definition, i|
          out.puts if i > 0
          definition.derives << :Default if false # TODO
          definition.write(out)
        end
      end
    end
  end

  task groups: %w(openapi.yaml) do |t|
    spec = OpenAI::Spec.parse(t.prerequisites.first)

    File.open('src/groups.rs', 'w') do |out|
      out.puts "// #{HEADER}"
      out.puts
      out.puts "//! OpenAI API types organized by group"
      out.puts
      spec.groups.each do |group|
        module_name = group.snake_case_id
        out.puts "pub mod #{module_name};"
      end
    end

    spec.groups.each do |group|
      module_name = group.snake_case_id
      module_path = Pathname("src/groups/#{module_name}.rs")
      File.open(module_path, 'w') do |out|
        out.puts "// #{HEADER}"
        out.puts
        out.puts "//! **OpenAI API: #{group.title}**"

        next if group.description.empty?
        out.puts "//!"
        wrap_text(inline_to_reference_links(group.description), 80-4).each do |line|
          out.puts "//! #{line}"
        end

        link_refs = link_refs(group.description)
        next if link_refs.empty?
        out.puts "//!"
        link_refs.each do |link_ref|
          out.puts "//! #{link_ref}"
        end
      end
    end
  end # :groups
end # :codegen

module OpenAPI
  class Type
    # def self.new(spec)
    #   Type.new(nil, spec)
    # end

    attr_reader :id, :ref, :type, :nullable, :default
    attr_reader :title, :description
    attr_reader :related_types

    def initialize(id, spec)
      spec = spec.dup
      @id = id ? id.to_sym : nil
      @ref = spec.delete('$ref')
      @type = spec['type'] ? spec.delete('type').to_sym : nil
      @nullable = spec.delete('nullable')
      @default = spec.delete('default')
      @title = spec.delete('title')
      @description = spec.delete('description')
      @spec = spec
      @related_types = []
    end

    def to_h
      @spec.dup.merge!({
        id: @id,
        '$ref': @ref,
        type: @type,
        nullable: @nullable,
        title: @title,
        description: @description,
      })
    end

    def nullable?() !!@nullable end
    def summary?() !self.summary.to_s.empty? end
    def summary() first_sentence(self.description) end

    def ref?() !!@ref end
    def recursive_ref?() !!@spec['$recursiveRef'] end
    def one_of?() !!@spec['oneOf'] end
    def any_of?() !!@spec['anyOf'] end
    def all_of?() !!@spec['allOf'] end
    def items?() !!@spec['items'] end
    def items() Type.new("#{self.id}_Item", @spec['items']) end
    def properties?() !!@spec['properties'] end

    def one_of
      (@spec['oneOf'] || []).map { |x| Type.new("#{self.id}_OneOf", x) } # FIXME
    end

    def any_of
      (@spec['anyOf'] || []).map { |x| Type.new("#{self.id}_AnyOf", x) } # FIXME
    end

    def all_of
      (@spec['allOf'] || []).map { |x| Type.new("#{self.id}_AllOf", x) } # FIXME
    end

    def properties
      (@spec['properties'] || {}).inject({}) do |result, (k, v)|
        result[Identifier.new(k)] = Type.new("#{self.id}_#{snake_to_camel(k)}", v) # FIXME
        result
      end
    end

    def to_rust_variant
      case
        when self.ref? then self.ref.split('/').last
        when self.one_of? then 'OneOf'
        when self.any_of? then 'AnyOf'
        when self.all_of? then 'AllOf'
        when self.items? || @type == :array then 'Array'
        when self.properties? || @type == :object then 'Object'
        else case @type
          when :boolean then 'Boolean'
          when :integer then 'Integer'
          when :number then 'Number'
          when :string then 'String'
          else raise NotImplementedError, self.inspect
        end
      end
    end

    def to_rust
      basetype = case
        when self.ref? then Rust::Types::Val.new(self.ref.split('/').last)
        when self.one_of?
          enum = Rust::Enum.new(self.id, derives: %i(Clone Debug)) do |definition|
            definition.comment = self.summary
            self.one_of.each do |t|
              next if t.recursive_ref? # skip $recursiveRef
              variant = Rust::Variant.new(t.to_rust_variant, t.to_rust)
              variant.comment = t.summary
              definition.variants << variant
            end
          end
          @related_types << enum
          enum
        when self.any_of?
          struct = Rust::Newtype.new(self.id, AnyOf, derives: %i(Clone Debug)) # TODO
          @related_types << struct
          struct
        when self.all_of?
          struct = Rust::Newtype.new(self.id, AllOf, derives: %i(Clone Debug)) # TODO
          @related_types << struct
          struct
        when self.items? || @type == :array # FIXME
          item_type = self.items.to_rust
          if self.is_a?(Rust::Definition) || self.items.ref?
            Rust::Types::Vec.new(item_type)
          else
            #p [item_type, self.items]
            struct = Rust::Struct.new(item_type, derives: %i(Clone Debug)) # TODO
            @related_types << struct
            struct
            Rust::Types::Vec.new(item_type)
          end
        when self.properties? || @type == :object
          struct = Rust::Struct.new(self.id, derives: %i(Clone Debug)) # TODO: fields
          @related_types << struct
          struct
        else case @type
          when :boolean then Rust::Types::Bool
          when :integer then Rust::Types::I64
          when :number then Rust::Types::F64
          when :string then Rust::Types::String
          else raise NotImplementedError, self.inspect
        end
      end
      @nullable ? Rust::Types::Option.new(basetype) : basetype
    end
  end

  class Identifier
    include Comparable

    attr_reader :id

    def initialize(id) @id = id end
    def <=>(other) self.id <=> other.id end
    def ==(other) self.id == other.id end
    def hash() @id.hash end
    def needs_rename?() @id.to_s.match?(/[\[\]\.]/) end
    def to_s() @id.to_s end
    def to_sym() @id.to_sym end
    def to_rust() @id.to_s.gsub('[]', '').gsub('.', '_') end
  end
end

module OpenAI
  class Spec
    def self.parse(path)
      self.new(YAML.load_file(path, aliases: true))
    end

    def initialize(spec) @spec = spec end

    def groups
      @spec['x-oaiMeta']['groups'].map { |g| Group.new(g) }.sort_by(&:snake_case_id)
    end

    def schemas
      @spec['components']['schemas'].map { |k, v| OpenAPI::Type.new(k, v) }.sort_by(&:id)
    end
  end # Spec

  class Group
    attr_reader :spec

    def initialize(spec) @spec = spec end
    def snake_case_id() @spec['id'].gsub('-', '_') end
    def title() @spec['title'] end
    def description() @spec['description'] end
  end
end # OpenAI

def wrap_text(text, max_width = 80)
  text.gsub(/(.{1,#{max_width}})(\s+|$)/, "\\1\n").split("\n")
end

def link_refs(markdown, base_url = BASE_URL)
  base_url = base_url.chomp('/')
  markdown.scan(/\[(.*?)\]\((\/[^)]*)\)/)
    .map { |_, path| "[#{path}]: #{base_url}#{path}" }
    .uniq
end

def inline_to_reference_links(markdown)
  markdown.gsub(/\[(.*?)\]\(((?!https:).*?)\)/, '[\1][\2]')
end

def first_sentence(text)
  text.to_s.gsub(/\s*\n+/, ' ').match(/^.*?[.!?](?:\s|$)/)&.[](0)&.strip || text.to_s.strip
end

def camel_to_snake(camel_string)
  camel_string.gsub(/([A-Z])/, '_\1').downcase.gsub(/^_/, '')
end

def snake_to_camel(snake_string)
  snake_string.gsub(/[_.]/, ' ').split.map(&:capitalize).join
end
