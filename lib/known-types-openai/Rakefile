require 'pathname'
require 'yaml'

HEADER = "This is free and unencumbered software released into the public domain."
BASE_URL = 'https://platform.openai.com'

namespace :codegen do
  task components: %w(openapi.yaml) do |t|
    spec = OpenAI::Spec.parse(t.prerequisites.first)

    File.open('src/components.rs', 'w') do |out|
      out.puts "// #{HEADER}"
      out.puts
      out.puts "//! OpenAI API components"

      spec.schemas.each do |schema|
        out.puts
        case schema.type
          when :boolean, :string, :array
            # Only `ParallelToolCalls` has a type of 'boolean'
            # Only 4 schemas have a type of 'array'
            # Some 12 schemas have a type of 'string'
            out.puts wrap_text(schema.summary, 80-4).map { |s| s.prepend("/// ") }.join("\n") if schema.summary?
            out.puts "#[derive(Clone, Debug, Default)]"
            out.puts "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
            # TODO: schema['default']
            out.puts "pub struct #{schema.id}(pub bool);" if schema.type == :boolean
            out.puts "pub struct #{schema.id}(pub String);" if schema.type == :string
            out.puts "pub struct #{schema.id}(pub Vec<String>);" if schema.type == :array # FIXME
          when :object
            out.puts wrap_text(schema.summary, 80-4).map { |s| s.prepend("/// ") }.join("\n") if schema.summary?
            out.puts "#[derive(Clone, Debug, Default)]"
            out.puts "#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]"
            out.puts "pub struct #{schema.id};" # TODO
          when nil # oneOf, anyOf, allOf
            # Some 49 schemas have a type of 'nil` with `oneOf`, `anyOf`, `allOf`, or `properties`
            out.puts "// TODO: pub enum #{schema.id};"
        end
      end
    end
  end

  task groups: %w(openapi.yaml) do |t|
    spec = OpenAI::Spec.parse(t.prerequisites.first)

    File.open('src/groups.rs', 'w') do |out|
      out.puts "// #{HEADER}"
      out.puts
      out.puts "//! OpenAI API types organized by group"
      spec.groups.each do |group|
        module_name = group.snake_case_id
        out.puts "pub mod #{module_name};"
      end
    end

    spec.groups.each do |group|
      module_name = group.snake_case_id
      module_path = Pathname("src/groups/#{module_name}.rs")
      File.open(module_path, 'w') do |out|
        out.puts "// #{HEADER}"
        out.puts
        out.puts "//! **OpenAI API: #{group.title}**"

        next if group.description.empty?
        out.puts "//!"
        wrap_text(inline_to_reference_links(group.description), 80-4).each do |line|
          out.puts "//! #{line}"
        end

        link_refs = link_refs(group.description)
        next if link_refs.empty?
        out.puts "//!"
        link_refs.each do |link_ref|
          out.puts "//! #{link_ref}"
        end
      end
    end
  end # :groups
end # :codegen

module OpenAI
  class Spec
    def self.parse(path)
      self.new(YAML.load_file(path, aliases: true))
    end

    def initialize(spec) @spec = spec end

    def groups
      @spec['x-oaiMeta']['groups'].map { |g| Group.new(g) }.sort_by(&:snake_case_id)
    end

    def schemas
      @spec['components']['schemas'].map { |k, v| Schema.new(k, v) }.sort_by(&:id)
    end
  end # Spec

  class Group
    def initialize(spec) @spec = spec end
    def snake_case_id() @spec['id'].gsub('-', '_') end
    def title() @spec['title'] end
    def description() @spec['description'] end
  end

  class Schema
    attr_reader :id
    def initialize(id, spec) @id, @spec = id, spec end
    def type() @spec['type'] ? @spec['type'].to_sym : nil end
    def summary?() !self.summary.to_s.empty? end
    def summary() first_sentence(self.description) end
    def description() @spec['description'] end
  end
end # OpenAI

def wrap_text(text, max_width = 80)
  text.gsub(/(.{1,#{max_width}})(\s+|$)/, "\\1\n").split("\n")
end

def link_refs(markdown, base_url = BASE_URL)
  base_url = base_url.chomp('/')
  markdown.scan(/\[(.*?)\]\((\/[^)]*)\)/)
    .map { |_, path| "[#{path}]: #{base_url}#{path}" }
    .uniq
end

def inline_to_reference_links(markdown)
  markdown.gsub(/\[(.*?)\]\(((?!https:).*?)\)/, '[\1][\2]')
end

def first_sentence(text)
  text.to_s.gsub(/\s*\n+/, ' ').match(/^.*?[.!?](?:\s|$)/)&.[](0)&.strip || text.to_s.strip
end
